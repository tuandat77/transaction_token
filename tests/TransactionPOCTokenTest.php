<?php

use Mockery as m;
use Ezdefi\Poc\TransactionPocToken;

class TransactionPOCTokenTest extends \PHPUnit\Framework\TestCase
{

    protected $privateKey = 'e6cba9375d93cd4356dfcacfba7e4dcdbd3b8c0868f6b6de6ccc7a5a799955b1';

    protected $addressTo = '0xbDCEBe3c64AA36209f6262024EEDCC98e1b1d661';

    private $transactionPocToken;

    protected function setUp() {
        parent::setUp();
        $this->transactionPocToken = new TransactionPocToken();
    }

    protected function tearDown()
    {
        m::close();

        parent::tearDown(); // TODO: Change the autogenerated stub
    }

    public function testPOCToWei()
    {
        // ReflectClass
        $convert_mock = m::mock( \Ezdefi\Poc\Converter::class );
        $convert_mock->shouldReceive( 'toWei' )->once()->with( 1 )->andReturn( 100 );

        $mock = m::mock( \Ezdefi\Poc\TransactionPocToken::class )->makePartial()->shouldAllowMockingProtectedMethods();
        $mock->shouldReceive( 'getConverter' )->once()->andReturn( $convert_mock );

        $this->assertEquals( dechex(100), $mock->ToWei(1) );
    }

    public function testConvertToAddressToken()
    {
        $mock = m::mock(\Ezdefi\Poc\TransactionPocToken::class)->makePartial()->shouldAllowMockingProtectedMethods();
        $mock->shouldReceive('convertToAddressToken')->once()->with($this->privateKey)->andReturn('abcxyz');

        $this->assertEquals('abcxyz',$mock->getAddressTokenFromPrivateKey($this->privateKey));
    }

    public function testGetPrivateKeyException()
    {
        try {
            $this->transactionPocToken->getPrivateKey('abc');
            $this->fail('not exception');
        } catch (\Exception $e) {
            $this->assertEquals('PrivateKey to is required',$e->getMessage());
        }
    }

    public function testGetMountException()
    {
        try {
            $this->transactionPocToken->getMount('abc');
            $this->fail('not exception');
        } catch (\Exception $e) {
            $this->assertEquals('Amount is required', $e->getMessage());
        }
    }

    public function testGetAddressToException()
    {
        try {
            $this->transactionPocToken->getAddressTo('abc');
            $this->fail('not exception');
        } catch (\Exception $e) {
            $this->assertEquals('Address to is required', $e->getMessage());
        }
    }

    public function testGetAddressContractException()
    {
        try {
            $this->transactionPocToken->getAddressContract('abc');
            $this->fail('not exception');
        } catch (\Exception $e) {
            $this->assertEquals('Address contract to is required', $e->getMessage());
        }
    }

    public function testGetTransactionCountFromBlock()
    {
        $address = 'fake-address';

        $ethD20Instance = new \Ethereum\DataType\EthD20($address);
        $ethBlockParamInstance = new \Ethereum\DataType\EthBlockParam();

        $nonceObject = m::mock(stdClass::class);
        $nonceObject->shouldReceive('val')->once()->andReturn('fake-nonce');

        $eth_mock = m::mock( \Ethereum\Ethereum::class )->makePartial();
        $eth_mock->shouldReceive('eth_getTransactionCount')->with($ethD20Instance, $ethBlockParamInstance)->andReturn($nonceObject);


        $mock = m::mock( TransactionPocToken::class )->makePartial();

        $mock->shouldReceive( 'connectEth' )->once()->andReturn($eth_mock);

        $this->assertEquals( 'fake-nonce', $mock->getTransactionCountFromBlock('fake-address') );
    }

}